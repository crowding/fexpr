% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/missing.R
\name{missing_value}
\alias{missing_value}
\alias{list_missing}
\alias{missing_}
\alias{missing_.dots}
\alias{missing_.default}
\alias{missing_.quotation}
\title{R's missing value.}
\usage{
missing_value(n)

list_missing(...)

missing_(x, unwrap = TRUE)

\method{missing_}{dots}(x, unwrap = TRUE)

\method{missing_}{default}(x, unwrap = TRUE)

\method{missing_}{quotation}(x, unwrap = TRUE)
}
\arguments{
\item{n}{Optional; a number. If provided, will return a list of
missing values with this many elements.}

\item{x}{a value, \link{dots}, or list.}

\item{unwrap}{Whether to descend through unevaluated promises
using \link{unwrap(x, TRUE)} before deciding if a promise is missing.}
}
\value{
The symbol with empty name, or a list of such.

\code{list_missing} A list containing the values of all arguments, including
missing values. That is, \code{list_missing} works like
\code{list}, but does not complain about missing arguments,
instead representing them directly.

\code{missing} returns a logical vector
}
\description{
The missing value (\code{R_MissingArg} at C level) has two related uses
in R's implementation. One is "at parse time" when it is used to
represent empty arguments. The other is "at run time" when it is
bound to function arguments that were not given any value.

\code{missing_} checks for missingness in R data.

For \code{[dots]} and \code{[quo]} objects, \code{missing()} checks whether the
expressions are missing without evaluating.
}
\details{
Manipulating expressions ("computing on the language") means we
have to deal with the first use case, because we have to be able to
make calls that have empty arguments, like the first index in
\code{arr[,c]}.

The second use of the missing sigil makes this tricky. Generally it
is a bad idea to assign a bare \code{missing_value} to a variable or use
one as the argument to a function, because this makes R think that
the variable \emph{is} missing rather than that it \emph{contains a}
missing. For instance, you can say

x <- list(missing_value(), 2, 3)

and get a valid list, but this:

a <- missing_value(); b <- 2; c <- 3
x <- list(a, b, c)

fails with an error about the missing variable "a". When dealing
with missing values, then, best to keep them wrapped up in lists,
\link{quotations} or others

Checking for missing arguments of \code{...}, without forcing, can be
useful if you need to implement array subsetting like \code{`[`},
where a missing argument means to take all indexes on that
dimension.

There is not a good way to emulate \code{`[`}'s behavior in base R;
using \code{list(\dots)} to collect all positional arguments will throw
errors on missing arguments. Meanwile, using
\code{substitute(list(...))[[2]]} gives you the unevaluated arguments,
but stripts them of their environments (breaking hygeine).

Instead, use \code{x <- list_missing(...)}
and \link{missing_}(x) to detect missing arguments.

[[2]: R:[2
}
\examples{
# These expressions are equivalent:
quote(function(x, y=1) x+y)
call("function", pairlist(x=missing_value(), y=1), call("+", as.name("x"), as.name("y"))

# These expressions are also equivalent:
quote(df[,1])
substitute(df[row,col], list(row = missing_value(), col = 1))
}
\seealso{
list_missing

missing, is_missing
}
