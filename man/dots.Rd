% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dots.R, R/conversions.R
\name{dots}
\alias{dots}
\alias{dots_}
\alias{exprs}
\alias{exprs.dots}
\alias{exprs<-}
\alias{exprs<-.dots}
\alias{envs}
\alias{envs.dots}
\alias{envs<-}
\alias{envs<-.dots}
\alias{[.dots}
\alias{[<-.dots}
\alias{forced.dots}
\alias{c.dots}
\alias{c.quotation}
\alias{as.data.frame.dots}
\alias{as.dots}
\title{Capture a number of unevaluated arguments as an object.}
\usage{
dots(...)

dots_(exprs, envs)

exprs(d)

\method{exprs}{dots}(d)

exprs(d) <- value

\method{exprs}{dots}(d) <- value

envs(d)

\method{envs}{dots}(d)

envs(d) <- value

\method{envs}{dots}(d) <- value

\method{[}{dots}(x, ..., drop = FALSE)

\method{[}{dots}(x, ...) <- value

\method{forced}{dots}(q)

\method{c}{dots}(...)

\method{c}{quotation}(...)

\method{as.data.frame}{dots}(x, row.names = NULL, ...)

as.dots(x)
}
\arguments{
\item{...}{Any number of arguments.}

\item{exprs}{An expression or list of expressions.}

\item{envs}{An environment or list of environments.}

\item{d}{A \link{dots} object.}

\item{value}{A replacement value.}

\item{x}{A \code{\link{dots}} object.}

\item{x}{a vector or list.}
}
\value{
A list with class 'dots', each element of which is a \link{quotation}.

\code{dots_(exprs, envs)} directly constructs a dots object
given lists of expresions and environments.

\code{exprs} returns a named list of expressions.

\code{envs(d)} returns a named list of environments.

\code{forced} returns a named logical vector.

\code{as.data.frame.dots} returns a data frame.

An object of class \code{\dots}. For \code{as.dots}, the
list items are treated as data values, and create already-forced
promises. For \code{as.dots.exprs}, values are used as the
expressions of new unforced promises.
}
\description{
A dots object represents a named list of \link{quotation}s. It mirrors R's
special variable \code{...}. Unlike \code{...}, a \code{dots} is:
\itemize{
\item immutable (evaluating does not change it),
\item first-class (you can give it any name, not just \code{...}),
\item data (The R interpreter treates it as literal data rather than
triggering argument splicing).
}

\code{exprs(d)} extracts a list of expressions.

The mutator \code{exprs(d) <- value} returns a new dots object with the new
expressions.

\code{envs(d)} extracts a list of environments from a \link{dots}
object. \code{envs(d) <- value} returns a dots object containing new
quotations with updated environments.

\code{forced} tests whether each element is forced (see \link{is_forced}.)

\code{as.data.frame.dots} transforms the contents of a \link{dots} object
into a data frame with one row per \link{quotation}, with columns:
\itemize{
\item \code{name}: a character,
\item \code{expr}: an expression,
\item \code{env}: an \link{environment} object or NULL if \link{forced},
\item \code{value}: NULL or a value if forced.
}
}
\details{
\code{d <- dots(...)} captures the contents of \code{...} without triggering
evaluation, and returns a list of class \code{"dots"}, each element of
which is a \code{[quotation]}. This improves on
\code{substitute(list(...))[[2]]} by capturing the context of each
expression along with the expressions.

\code{d <- dots(foo, quux=bar+baz)} captures all of the given arguments
in a dots object, like \code{[alist]}, but also captures the
environment of each argument (The present environment in this case).

[[2]: R:[2
[alist]: R:alist
}
\note{
The columns have a class \link{"oneline"} for better printing.
}
\examples{

named.list <- function(...) {
 # Collect only named arguments, ignoring unnamed arguments.
 d <- dots(...)
 do(list, d[names(d) != ""])
}

named.list(a=1, b=2*2, stop("this is not evaluated"))
}
